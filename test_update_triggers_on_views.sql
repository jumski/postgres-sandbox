\qecho '---------- Schema setup ------------'

-- schema boilerplate
create schema if not exists test_update_triggers_on_views;
set search_path to test_update_triggers_on_views;
drop view if exists tasks_with_users;
drop table if exists tasks;
drop table if exists users;

-- tables
create table if not exists users (
  id int generated by default as identity primary key,
  name text
);
create table if not exists tasks (
  id int generated by default as identity primary key,
  user_id int references users(id),
  name text
);

-- view
create or replace view tasks_with_users as (
  select
    tasks.id as task_id,
    tasks.name as task_name,
    users.id as user_id,
    users.name as user_name
  from tasks
  left join users on tasks.user_id = users.id
);

-- fail on any errors below
\set ON_ERROR_STOP TRUE

-- function that accepts tasks_with_users row and updates users table,
-- setting users.name to tasks_with_users.user_name
create or replace function update_users_and_tasks() returns trigger AS
$body$
begin
  update users set name = new.user_name where users.id = new.user_id;
  return new;
end;
$body$ language plpgsql;

-- create a trigger on tasks_with_users view
create trigger update_users_and_tasks_trigger
  instead of update
  on tasks_with_users
  for each row
  execute procedure update_users_and_tasks();

-- insert some data
insert into users (name) values ('john'), ('andrew');
insert into tasks (user_id, name) values
  (1, 'first john task'),
  (1, 'second john task');
insert into tasks (user_id, name) values
  (2, 'first andrew task'),
  (2, 'second andrew task');

-- show data in tables and view
select * from users;
select * from tasks;
select * from tasks_with_users;

-- update the view, checkign if trigger works
update tasks_with_users
  set user_name = 'new john'
  where task_id = 1
  and user_id = 1;

-- ensure data changed
select * from users;
select * from tasks;
select * from tasks_with_users;

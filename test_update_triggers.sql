\qecho '---------- Schema setup ------------'

CREATE schema IF NOT EXISTS test_update_triggers;
SET search_path TO test_update_triggers;
DROP TABLE IF EXISTS group_events CASCADE;
DROP TABLE IF EXISTS groups CASCADE;

CREATE TABLE IF NOT EXISTS groups (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  transition_state text,
  premium_value NUMERIC NOT NULL
);
CREATE TABLE IF NOT EXISTS group_events (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  event_date timestamptz NOT NULL,
  event_name text NOT NULL,
  group_id int references groups(id)
);

-- fail on any errors below
\set ON_ERROR_STOP TRUE

-- function that returns event name for difference between OLD and NEW rows
-- returns NULL if no event should be created
CREATE OR replace FUNCTION event_name_for_changes(OLD groups, NEW groups) RETURNS text AS
$body$
BEGIN
  RETURN
    CASE
    WHEN OLD.transition_state = 'lead' AND NEW.transition_state = 'prospect' THEN 'convert_to_prospect'
    WHEN OLD.transition_state = 'prospect' AND NEW.transition_state = 'customer' THEN 'convert_to_customer'
    END;
END;
$body$ LANGUAGE plpgsql;

-- trigger that watches updates to `groups` table and creates new events
CREATE OR REPLACE FUNCTION create_group_event() RETURNS TRIGGER AS
$body$
DECLARE
  event_name text;
BEGIN
  event_name := event_name_for_changes(OLD, NEW);

  IF event_name IS NOT NULL THEN
    INSERT INTO group_events(event_date, event_name, group_id)
      VALUES(NOW(), event_name, NEW.id);
  END IF;

  RETURN NEW;
END;
$body$ language plpgsql;

CREATE TRIGGER create_group_event_trigger
  AFTER UPDATE
  ON groups
  FOR EACH ROW
  EXECUTE PROCEDURE create_group_event();

INSERT INTO groups(transition_state, premium_value) VALUES ('lead', 100), ('prospect', 200), ('customer', 300);
SELECT * FROM groups;
SELECT * FROM group_events;

UPDATE groups SET transition_state = 'prospect' WHERE transition_state = 'lead';
UPDATE groups SET premium_value = 200 WHERE premium_value = 100;
SELECT * FROM group_events;

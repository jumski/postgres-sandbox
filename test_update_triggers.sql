\qecho '---------- Schema setup ------------'

CREATE schema IF NOT EXISTS test_update_triggers;
SET search_path TO test_update_triggers;
DROP TABLE IF EXISTS group_events CASCADE;
DROP TABLE IF EXISTS groups CASCADE;

CREATE TABLE IF NOT EXISTS groups (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  transition_state text,
  statuses text[] DEFAULT '{}'::text[] NOT NULL,
  premium_value NUMERIC NOT NULL
);
CREATE TABLE IF NOT EXISTS group_events (
  id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  event_date timestamptz NOT NULL,
  event_name text NOT NULL,
  group_id int references groups(id)
);

-- fail on any errors below
\set ON_ERROR_STOP TRUE

CREATE OR replace FUNCTION array_subtract(minuend text[], subtrahend text[]) RETURNS text[] AS
$body$
BEGIN
  RETURN (SELECT ARRAY(SELECT UNNEST(minuend) EXCEPT SELECT UNNEST(subtrahend)))::text[];
END;
$body$ LANGUAGE plpgsql;

/* CREATE OR replace FUNCTION removed_statuses(OLD groups, NEW groups) RETURNS text[] AS */
/* $body$ */
/* BEGIN */
/*   RETURN SELECT ARRAY(SELECT UNNEST(OLD.statuses) EXCEPT SELECT UNNEST(NEW.statuses)); */
/* END; */
/* $body$ LANGUAGE plpgsql; */

/* CREATE OR replace FUNCTION added_statuses(OLD groups, NEW groups) RETURNS text[] AS */
/* $body$ */
/* BEGIN */
/*   RETURN SELECT ARRAY(SELECT UNNEST(NEW.statuses) EXCEPT SELECT UNNEST(OLD.statuses)); */
/* END; */
/* $body$ LANGUAGE plpgsql; */

-- function that returns event name for difference between OLD and NEW rows
-- returns NULL if no event should be created
CREATE OR replace FUNCTION event_name_for_changes(OLD groups, NEW groups) RETURNS text AS
$body$
DECLARE
  added_statuses text[];
  removed_statuses text[];
BEGIN
  IF OLD.transition_state = 'lead' AND NEW.transition_state = 'prospect' THEN
    RETURN 'convert_to_prospect';
  END IF;

  IF OLD.transition_state = 'prospect' AND NEW.transition_state = 'customer' THEN
    RETURN 'convert_to_customer';
  END IF;

  IF OLD.statuses != NEW.statuses THEN
    added_statuses := array_subtract(NEW.statuses, OLD.statuses);
    removed_statuses := array_subtract(OLD.statuses, NEW.statuses);
    RETURN 'statuses_changed';
  END IF;

  RETURN NULL;

  /* IF OLD.transition_state = 'prospect' AND NEW.transition_state = 'prospect' */
  /*    AND NOT OLD.statuses @> ARRAY['quoted'] AND OLD.statuses @> ARRAY['quoted'] THEN 'convert_to_prospect' *1/ */
END;
$body$ LANGUAGE plpgsql;

-- trigger that watches updates to `groups` table and creates new events
CREATE OR REPLACE FUNCTION create_group_event() RETURNS TRIGGER AS
$body$
DECLARE
  event_name text;
BEGIN
  event_name := event_name_for_changes(OLD, NEW);

  IF event_name IS NOT NULL THEN
    INSERT INTO group_events(event_date, event_name, group_id)
      VALUES(NOW(), event_name, NEW.id);
  END IF;

  RETURN NEW;
END;
$body$ language plpgsql;

CREATE TRIGGER create_group_event_trigger
  AFTER UPDATE
  ON groups
  FOR EACH ROW
  EXECUTE PROCEDURE create_group_event();

INSERT INTO groups(transition_state, premium_value) VALUES ('lead', 100), ('prospect', 200), ('customer', 300);
SELECT * FROM groups;
SELECT * FROM group_events;

UPDATE groups SET transition_state = 'prospect' WHERE transition_state = 'lead';
UPDATE groups SET premium_value = 200 WHERE premium_value = 100;
UPDATE groups SET statuses = ARRAY['yolo', 'flaki'] WHERE transition_state = 'customer';
SELECT * FROM group_events;
